<?php

namespace App\Http\Controllers\admin\vulnerability_management;

use App\Events\VulnerabilityCreated;
use App\Events\VulnerabilityDeleted;
use App\Events\VulnerabilityUpdated;
use App\Exports\VulnerabilitiesExport;
use App\Http\Controllers\Controller;
use App\Imports\ClosedVulnerabilitiesImport;
use App\Imports\VulnerabilitiesImport;
use App\Jobs\SendVulnerabilityEmail;
use App\Models\Action;
use App\Models\Asset;
use App\Models\AssetGroup;
use App\Models\AssetVulnerability;
use App\Models\ControlNotificationVulnToAssetOwner;
use App\Models\Department;
use App\Models\HostRegion;
use App\Models\Team;
use App\Models\TeamVulnerability;
use App\Models\TeamVulnerabilityInfo;
use App\Models\User;
use App\Models\Vulnerability;
use App\Models\VulnerabilityInfo;
use App\Services\VulnsExportService;
use Carbon\Carbon;
use Illuminate\Validation\Rule;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Validator;
use Maatwebsite\Excel\Facades\Excel;
use Illuminate\Support\Str;



class VulnerabilityManagementController extends Controller
{

    protected $vulnsExportService;

    // Inject the VulnsExportService into the controller
    public function __construct(VulnsExportService $vulnsExportService)
    {
        $this->vulnsExportService = $vulnsExportService;
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        $users = User::select('id', 'name')->where('enabled', true)->get();
        $assets = Asset::select('id', 'name')->get();
        $teams = Team::select('id', 'name')->get();
        $ips = Asset::whereNotNull('ip')->distinct()->pluck('ip');
        $regions = HostRegion::select('id', 'name')->get();
        $owners = User::select('id', 'name')->get();
        $assetgroups = AssetGroup::select('id', 'name')->get();
    
        $vulns = $this->GetStaticsVuln();
    
        $breadcrumbs = [
            ['link' => route('admin.dashboard'), 'name' => __('locale.Dashboard')],
            ['name' => __('locale.VulnerabilityManagement')]
        ];
    
        // Pass all required variables
        return view('admin.content.vulnerability_management.index', compact(
            'breadcrumbs',
            'vulns',
            'users',
            'assets',
            'teams',
            'ips',
            'regions',
            'assetgroups', // Add this variable
            'owners',
        ));
    }
    
    
    public function indexInfo()
    {
        $users = User::select('id', 'name')->where('enabled', true)->get();
        $assets =  Asset::select('id', 'name')->get();;
        $teams = Team::select('id', 'name')->get();
        $ips = Asset::whereNotNull('ip')->distinct()->pluck('ip');
        $regions = HostRegion::select('id', 'name')->get();

        $breadcrumbs = [['link' => route('admin.dashboard'), 'name' => __('locale.Dashboard')], ['name' => __('locale.VulnerabilityManagement')]];

        return view('admin.content.vulnerability_management.indexInfo', compact('breadcrumbs', 'users', 'assets', 'teams', 'ips', 'regions'));
    }
    private function GetStaticsVuln()
    {
        // Retrieve the vulnerability counts for each status
        $vuln = Vulnerability::selectRaw('status, count(*) as count')
            ->groupBy('status')
            ->get()
            ->keyBy('status'); // Key by 'status' for direct access

        // Total count of all vulnerabilities
        $totalVulns = Vulnerability::count();

        // Prepare the vulnerability information array with percentages
        $openVuln = $vuln->get('Open')->count ?? 0;
        $closedVuln = $vuln->get('Closed')->count ?? 0;
        $progressVuln = $vuln->get('In Progress')->count ?? 0;

        return [
            'openVulnerability' => [
                'count' => $openVuln,
                'percentage' => $totalVulns > 0 ? round(($openVuln / $totalVulns) * 100, 2) : 0,
            ],
            'closedVulnerability' => [
                'count' => $closedVuln,
                'percentage' => $totalVulns > 0 ? round(($closedVuln / $totalVulns) * 100, 2) : 0,
            ],
            'progressVulnerability' => [
                'count' => $progressVuln,
                'percentage' => $totalVulns > 0 ? round(($progressVuln / $totalVulns) * 100, 2) : 0,
            ],
            'overview' => $totalVulns,
        ];
    }


    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'name' => ['required', 'max:255'],
            'ip_address' => ['required', 'max:15'],
            'cve' => ['required', 'max:255'],
            'assets' => ['required', 'array'],
            'assets.*' => ['exists:assets,id'],
            // 'teams' => ['required', 'array'],
            // 'teams.*' => ['exists:teams,id'],
            'severity' => ['required', Rule::in(['Critical', 'High', 'Medium', 'Low', 'Informational'])],
            'description' => ['required', 'string'],
            'recommendation' => ['required', 'string'],
            'first_discovered' => ['required'],
            'plan' => ['required', 'string'],
            'status' => ['required', Rule::in(['Open', 'In Progress', 'Closed', 'Overdue'])],
        ]);

        // Check if there is any validation errors
        if ($validator->fails()) {
            $errors = $validator->errors()->toArray();

            $response = array(
                'status' => false,
                'errors' => $errors,
                'message' => __('vulnerability.ThereWasAProblemAddingTheVulnerability') . "<br>" . __('locale.Validation error'),
            );
            return response()->json($response, 422);
        } else {
            DB::beginTransaction();
            try {
                $vulnerability = Vulnerability::create([
                    'name' => $request->name,
                    'ip_address'  => $request->ip_address,
                    'cve' => $request->cve,
                    'severity' => $request->severity,
                    'description' => $request->description,
                    'recommendation' => $request->recommendation,
                    'plan' => $request->plan,
                    'status' => $request->status,
                    'netbios_name' => $request->netbios_name,
                    'dns_name' => $request->dns_name,
                    'plugin_id' => $request->plugin_id,
                    'protocol' => $request->protocol,
                    'port' => $request->port,
                    'exploit' => $request->exploit,
                    'synopsis' => $request->synopsis,
                    'first_discovered' => $request->first_discovered,
                    'last_observed' => $request->last_observed,
                    'plugin_publication_date' => $request->plugin_publication_date,
                    'plugin_modification_date' => $request->plugin_modification_date,
                    'created_by' => auth()->id()
                ]);

                // Store vulnerability teams
                $allVulnerabilityTeams = Team::whereIn('id', $request->teams ?? [])->get();
                $vulnerability->teams()->saveMany($allVulnerabilityTeams);

                // Store vulnerability assets
                $allVulnerabilityAssets = Asset::whereIn('id', $request->assets ?? [])->get();
                $vulnerability->assets()->saveMany($allVulnerabilityAssets);

                // Audit log
                $message = __("vulnerability.A vulnerability named") . " \"" . $vulnerability->name . "\" " . __("locale.CreatedBy") . " \"" . auth()->user()->name . "\".";
                write_log($vulnerability->id, auth()->id(), $message, 'vulnerability');

                DB::commit();
                event(new VulnerabilityCreated($vulnerability, $allVulnerabilityAssets));
                $response = array(
                    'status' => true,
                    'message' => __('vulnerability.VulnerabilityWasAddedSuccessfully'),
                );
                return response()->json($response, 200);
            } catch (\Throwable $th) {

                $response = array(
                    'status' => false,
                    'errors' => [],
                    // 'message' => $th->getMessage(),
                    'message' => __('locale.ThereAreUnexpectedProblems')
                );
                return response()->json($response, 502);

                $response = array(
                    'status' => false,
                    'errors' => [],
                    'message' => __('locale.Error'),
                );
                return response()->json($response, 502);
            }
        }
    }
    // a function to get the assets related to an ip
    public function getIpAssets(Request $request)
    {
        $assets = [];
        $assetOwner = null;  // Default owner is null

        if ($request->ip_address != null) {
            if ($request->ip_address == "no_ip") {
                $assets =  Asset::select('id', 'name', 'asset_owner')->where('ip', 'no_ip')->orwhere('ip', null)->get();
            } else {
                $assets =  Asset::select('id', 'name', 'asset_owner')->where('ip', $request->ip_address)->get();
            }
        }

        // If assets are found, get the owner ID of the first asset (assuming all assets have the same owner)
        if ($assets->isNotEmpty()) {
            $assetOwner = $assets->first()->asset_owner; // Fetch the owner ID from the first asset
        }

        return response()->json([
            'assets' => $assets,
            'asset_owner' => $assetOwner
        ]);
    }


    /**
     * Get specified resource data for editing.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function ajaxGet($id)
    {
        $vulnerability = Vulnerability::with('teams:id', 'assets:id')->find($id);
        if ($vulnerability) {
            $data = $vulnerability->toArray();
            $teams = array_map(function ($team) {
                return $team['id'];
            }, $vulnerability->teams->toArray());

            $assets = array_map(function ($team) {
                return $team['id'];
            }, $vulnerability->assets->toArray());

            $ipAssets = [];
            if ($vulnerability->ip_address == "no_ip"  || $vulnerability->ip_address == null) {
                $ipAssets =  Asset::select('id', 'name')->where('ip', null)->get();
            } else {
                $ipAssets =  Asset::select('id', 'name')->where('ip', $vulnerability->ip_address)->get();
            }
            $data['ip_assets'] = $ipAssets;
            $data['assets'] = $assets;
            $data['teams'] = $teams;
            $data['created_at'] = $vulnerability->created_at->format('Y-m-d H:i');
            // Get the asset_owner IDs for the selected assets
            $assetIds = AssetVulnerability::where('vulnerability_id', $vulnerability->id)
                ->pluck('asset_id')->toArray();

            // Fetch the owners of these assets
            $assetOwners = Asset::whereIn('id', $assetIds)
                ->pluck('asset_owner')
                ->unique() // Ensure we only get unique owners
                ->toArray();
            $data['asset_owner'] = $assetOwners; // Return the array of asset owners



            $response = array(
                'status' => true,
                'data' => $data,
            );
            return response()->json($response, 200);
        } else {
            $response = array(
                'status' => false,
                'message' => __('locale.Error 404'),
            );
            return response()->json($response, 404);
        }
    }

    public function ajaxGetInfo($id)
    {
        $vulnerability = VulnerabilityInfo::with('teams:id', 'assets:id')->find($id);
        if ($vulnerability) {
            $data = $vulnerability->toArray();
            $teams = array_map(function ($team) {
                return $team['id'];
            }, $vulnerability->teams->toArray());

            $assets = array_map(function ($team) {
                return $team['id'];
            }, $vulnerability->assets->toArray());

            $ipAssets = [];
            if ($vulnerability->ip_address == "no_ip"  || $vulnerability->ip_address == null) {
                $ipAssets =  Asset::select('id', 'name')->where('ip', null)->get();
            } else {
                $ipAssets =  Asset::select('id', 'name')->where('ip', $vulnerability->ip_address)->get();
            }
            $data['ip_assets'] = $ipAssets;
            $data['assets'] = $assets;
            $data['teams'] = $teams;
            $data['created_at'] = $vulnerability->created_at->format('Y-m-d H:i');


            $response = array(
                'status' => true,
                'data' => $data,
            );
            return response()->json($response, 200);
        } else {
            $response = array(
                'status' => false,
                'message' => __('locale.Error 404'),
            );
            return response()->json($response, 404);
        }
    }
    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        $vulnerability = Vulnerability::with('teams:id', 'assets:id')->find($id);
        if ($vulnerability) {
            $validator = Validator::make($request->all(), [
                'name' => ['required', 'max:255'],
                'ip_address' => ['required', 'max:15'],
                'cve' => ['required', 'max:255'],
                'assets' => ['required', 'array'],
                'assets.*' => ['exists:assets,id'],
                'teams' => ['required', 'array'],
                'teams.*' => ['exists:teams,id'],
                'severity' => ['required', Rule::in(['Critical', 'High', 'Medium', 'Low', 'Informational'])],
                'description' => ['required', 'string'],
                'recommendation' => ['required', 'string'],
                'plan' => ['required', 'string'],
                'first_discovered' => ['required'],
                'status' => ['required', Rule::in(['Open', 'In Progress', 'Closed', 'Overdue'])],
                'exploit' => ['nullable', Rule::in(['yes', 'no'])],
                'port' => ['nullable', 'integer'],
            ]);

            // Check if there is any validation errors
            if ($validator->fails()) {
                $errors = $validator->errors()->toArray();

                $response = array(
                    'status' => false,
                    'errors' => $errors,
                    'message' => __('vulnerability.ThereWasAProblemUpdatingTheVulnerability') . "<br>" . __('locale.Validation error'),
                );
                return response()->json($response, 422);
            } else {
                DB::beginTransaction();
                try {
                    // Update vulnerability teams
                    $currentTeams = array_map(function ($team) {
                        return $team['id'];
                    }, $vulnerability->teams->toArray());
                    $deletedTeams = array_diff($currentTeams ?? [], $request->teams ?? []);
                    $addedTeams = array_diff($request->teams ?? [], $currentTeams ?? []);

                    // Delete deleted teams
                    $vulnerability->teams()->detach($deletedTeams);

                    // Add added teams
                    $allVulnerabilityTeams = Team::whereIn('id', $addedTeams ?? [])->get();
                    $vulnerability->teams()->saveMany($allVulnerabilityTeams);

                    // Update vulnerability assets
                    $currentAssets = array_map(function ($team) {
                        return $team['id'];
                    }, $vulnerability->assets->toArray());
                    $deletedAssets = array_diff($currentAssets ?? [], $request->assets ?? []);
                    $addedAssets = array_diff($request->assets ?? [], $currentAssets ?? []);

                    // Delete deleted assets
                    $vulnerability->assets()->detach($deletedAssets);

                    // Add added assets
                    $allVulnerabilityAssets = Asset::whereIn('id', $addedAssets ?? [])->get();
                    $vulnerability->assets()->saveMany($allVulnerabilityAssets);

                    $updatedData = [
                        'name' => $request->name,
                        'ip_address' => $request->ip_address,
                        'cve' => $request->cve,
                        'severity' => $request->severity,
                        'description' => $request->description,
                        'recommendation' => $request->recommendation,
                        'plan' => $request->plan,
                        'status' => $request->status,
                        'netbios_name' => $request->netbios_name,
                        'dns_name' => $request->dns_name,
                        'plugin_id' => $request->plugin_id,
                        'protocol' => $request->protocol,
                        'port' => $request->port,
                        'exploit' => $request->exploit,
                        'synopsis' => $request->synopsis,
                        'first_discovered' => $request->first_discovered,
                        'last_observed' => $request->last_observed,
                        'plugin_publication_date' => $request->plugin_publication_date,
                        'plugin_modification_date' => $request->plugin_modification_date,
                        'created_by' => auth()->id()
                    ];

                    // Vulnerability status changed
                    if ($vulnerability->status != $request->status) {
                        $updatedData['update_status_date'] = now();
                        $updatedData['update_status_user'] = auth()->id();
                    }

                    $vulnerability->update($updatedData);
                    // Audit log
                    $message = __("vulnerability.A vulnerability named") . " \"" . $vulnerability->name . "\" " . __("locale.UpdatedBy") . " \"" . auth()->user()->name . "\".";
                    write_log($vulnerability->id, auth()->id(), $message, 'vulnerability');
                    DB::commit();
                    event(new VulnerabilityUpdated($vulnerability, $allVulnerabilityAssets));
                    $response = array(
                        'status' => true,
                        'message' => __('vulnerability.VulnerabilityWasUpdatedSuccessfully'),
                    );
                    return response()->json($response, 200);
                } catch (\Throwable $th) {
                    DB::rollBack();

                    $response = array(
                        'status' => false,
                        'errors' => [],
                        // 'message' => $th->getMessage(),
                        'message' => __('locale.Error'),
                    );
                    return response()->json($response, 502);
                }
            }
        } else {
            $response = array(
                'status' => false,
                'message' => __('locale.Error 404'),
            );
            return response()->json($response, 404);
        }
    }

    public function updateInfo(Request $request, $id)
    {
        $vulnerability = VulnerabilityInfo::with('teams:id', 'assets:id')->find($id);
        if ($vulnerability) {
            $validator = Validator::make($request->all(), [
                'name' => ['required', 'max:255'],
                'ip_address' => ['required', 'max:15'],
                'cve' => ['required', 'max:255'],
                'assets' => ['required', 'array'],
                'assets.*' => ['exists:assets,id'],
                'teams' => ['required', 'array'],
                'teams.*' => ['exists:teams,id'],
                'severity' => ['required', Rule::in(['Critical', 'High', 'Medium', 'Low', 'Informational'])],
                'description' => ['required', 'string'],
                'recommendation' => ['required', 'string'],
                'plan' => ['required', 'string'],
                'first_discovered' => ['required'],
                'status' => ['required', Rule::in(['Open', 'In Progress', 'Closed', 'Overdue'])],
                'exploit' => ['nullable', Rule::in(['yes', 'no'])],
                'port' => ['nullable', 'integer'],
            ]);

            // Check if there is any validation errors
            if ($validator->fails()) {
                $errors = $validator->errors()->toArray();

                $response = array(
                    'status' => false,
                    'errors' => $errors,
                    'message' => __('vulnerability.ThereWasAProblemUpdatingTheVulnerability') . "<br>" . __('locale.Validation error'),
                );
                return response()->json($response, 422);
            } else {
                DB::beginTransaction();
                try {
                    // Update vulnerability teams
                    $currentTeams = array_map(function ($team) {
                        return $team['id'];
                    }, $vulnerability->teams->toArray());
                    $deletedTeams = array_diff($currentTeams ?? [], $request->teams ?? []);
                    $addedTeams = array_diff($request->teams ?? [], $currentTeams ?? []);

                    // Delete deleted teams
                    $vulnerability->teams()->detach($deletedTeams);

                    // Add added teams
                    $allVulnerabilityTeams = Team::whereIn('id', $addedTeams ?? [])->get();
                    $vulnerability->teams()->saveMany($allVulnerabilityTeams);

                    // Update vulnerability assets
                    $currentAssets = array_map(function ($team) {
                        return $team['id'];
                    }, $vulnerability->assets->toArray());
                    $deletedAssets = array_diff($currentAssets ?? [], $request->assets ?? []);
                    $addedAssets = array_diff($request->assets ?? [], $currentAssets ?? []);

                    // Delete deleted assets
                    $vulnerability->assets()->detach($deletedAssets);

                    // Add added assets
                    $allVulnerabilityAssets = Asset::whereIn('id', $addedAssets ?? [])->get();
                    $vulnerability->assets()->saveMany($allVulnerabilityAssets);

                    $updatedData = [
                        'name' => $request->name,
                        'ip_address' => $request->ip_address,
                        'cve' => $request->cve,
                        'severity' => $request->severity,
                        'description' => $request->description,
                        'recommendation' => $request->recommendation,
                        'plan' => $request->plan,
                        'status' => $request->status,
                        'netbios_name' => $request->netbios_name,
                        'dns_name' => $request->dns_name,
                        'plugin_id' => $request->plugin_id,
                        'protocol' => $request->protocol,
                        'port' => $request->port,
                        'exploit' => $request->exploit,
                        'synopsis' => $request->synopsis,
                        'first_discovered' => $request->first_discovered,
                        'last_observed' => $request->last_observed,
                        'plugin_publication_date' => $request->plugin_publication_date,
                        'plugin_modification_date' => $request->plugin_modification_date,
                        'created_by' => auth()->id()
                    ];

                    // Vulnerability status changed
                    if ($vulnerability->status != $request->status) {
                        $updatedData['update_status_date'] = now();
                        $updatedData['update_status_user'] = auth()->id();
                    }

                    $vulnerability->update($updatedData);

                    // Audit log
                    $message = __("vulnerability.A vulnerability named") . " \"" . $vulnerability->name . "\" " . __("locale.UpdatedBy") . " \"" . auth()->user()->name . "\".";
                    write_log($vulnerability->id, auth()->id(), $message, 'vulnerability');
                    DB::commit();
                    // event(new VulnerabilityUpdated($vulnerability, $allVulnerabilityAssets));
                    $response = array(
                        'status' => true,
                        'message' => __('vulnerability.VulnerabilityWasUpdatedSuccessfully'),
                    );
                    return response()->json($response, 200);
                } catch (\Throwable $th) {
                    DB::rollBack();

                    $response = array(
                        'status' => false,
                        'errors' => [],
                        // 'message' => $th->getMessage(),
                        'message' => __('locale.Error'),
                    );
                    return response()->json($response, 502);
                }
            }
        } else {
            $response = array(
                'status' => false,
                'message' => __('locale.Error 404'),
            );
            return response()->json($response, 404);
        }
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($id)
    {
        $vulnerability = Vulnerability::find($id);
        $vulnerabilityName = $vulnerability->name;
        $vulnerabilityId = $vulnerability->id;
        $vulnerability->teams = $vulnerability->teams;
        $vulnerability->assets = $vulnerability->assets;
        $allVulnerabilityAssets = $vulnerability->assets;
        if ($vulnerability) {
            DB::beginTransaction();
            try {
                $vulnerability->delete();

                // Audit log
                $message = __("vulnerability.A vulnerability named") . " \"" . $vulnerabilityName . "\" was deleted by username \"" . auth()->user()->name . "\".";
                write_log($vulnerabilityId, auth()->id(), $message, 'vulnerability');

                DB::commit();
                event(new VulnerabilityDeleted($vulnerability, $allVulnerabilityAssets));
                $response = array(
                    'status' => true,
                    'message' => __('vulnerability.VulnerabilityWasDeletedSuccessfully'),
                );
                return response()->json($response, 200);
            } catch (\Throwable $th) {
                DB::rollBack();

                if ($th->errorInfo[0] == 23000) {
                    $errorMessage = __('vulnerability.ThereWasAProblemDeletingTheVulnerability') . "<br>" . __('locale.CannotDeleteRecordRelationError');
                } else {
                    $errorMessage = __('vulnerability.ThereWasAProblemDeletingTheVulnerability');
                }
                $response = array(
                    'status' => false,
                    'message' => $errorMessage,
                    // 'message' => $th->getMessage(),
                );
                return response()->json($response, 404);
            }
        } else {
            $response = array(
                'status' => false,
                'message' => __('locale.Error 404'),
            );
            return response()->json($response, 404);
        }
    }


    public function destroyInfo($id)
    {
        $vulnerability = VulnerabilityInfo::find($id);
        $vulnerabilityName = $vulnerability->name;
        $vulnerabilityId = $vulnerability->id;
        $vulnerability->teams = $vulnerability->teams;
        $vulnerability->assets = $vulnerability->assets;
        $allVulnerabilityAssets = $vulnerability->assets;
        if ($vulnerability) {
            DB::beginTransaction();
            try {
                $vulnerability->delete();

                // Audit log
                $message = __("vulnerability.A vulnerability named") . " \"" . $vulnerabilityName . "\" was deleted by username \"" . auth()->user()->name . "\".";
                write_log($vulnerabilityId, auth()->id(), $message, 'vulnerability');

                DB::commit();
                $response = array(
                    'status' => true,
                    'message' => __('vulnerability.VulnerabilityWasDeletedSuccessfully'),
                );
                return response()->json($response, 200);
            } catch (\Throwable $th) {
                DB::rollBack();

                if ($th->errorInfo[0] == 23000) {
                    $errorMessage = __('vulnerability.ThereWasAProblemDeletingTheVulnerability') . "<br>" . __('locale.CannotDeleteRecordRelationError');
                } else {
                    $errorMessage = __('vulnerability.ThereWasAProblemDeletingTheVulnerability');
                }
                $response = array(
                    'status' => false,
                    'message' => $errorMessage,
                    // 'message' => $th->getMessage(),
                );
                return response()->json($response, 404);
            }
        } else {
            $response = array(
                'status' => false,
                'message' => __('locale.Error 404'),
            );
            return response()->json($response, 404);
        }
    }
    /**
     * Return a listing of the resource after some manipulation depending on current user
     * if is admin all data returned
     * else returned data will depending on vulnerability creator or current user team.
     *
     * @param  \Illuminate\Http\Request  $request
     *
     * @return \Illuminate\Http\Response
     */
    public function ajaxGetList(Request $request)
    {

        // Initialize variables
        $dataTableDetails = [];
        $customFilterFields = [
            'normal' => ['plugin_id', 'name', 'cve', 'severity', 'status', 'exploit', 'tenable_status'],
            'relationships' => ['assets'],
            'other_global_filters' => ['created_at'],
        ];
        $relationshipsWithColumns = [
            'assets:ip',
            // 'teams:name'
        ];

        prepareDatatableRequestFields($request, $dataTableDetails, $customFilterFields);

        // Handle user permissions
        $currentUser = auth()->user();
        $conditions = [];

        // Get region filter from request
        $filterregion = $request->columns[13]['search']['value'] ?? '';
        $filterassetGroup = $request->columns[14]['search']['value'] ?? '';
        $allVulnerabilitiesId = null;

        if (!$currentUser->hasPermission('vulnerability_management.all')) {
            if (isDepartmentManager()) {
                $departmentId = Department::where('manager_id', auth()->id())->first()->id;
                $departmentMembers = User::with('teams')->where('department_id', $departmentId)->orWhere('id', auth()->id())->get();
                $departmentMembersIds = $departmentMembers->pluck('id')->toArray();
                $departmentTeams = [];
                foreach ($departmentMembers as $departmentMember) {
                    $departmentTeams = array_merge($departmentTeams, $departmentMember->teams->pluck('id')->toArray());
                }
                $vulnerabilitiesFromTeamIds = TeamVulnerability::whereIn('team_id', $departmentTeams)->pluck('vulnerability_id')->toArray();
                $vulnerabilitiesFromCurrentUserIds = Vulnerability::whereIn('created_by', $departmentMembersIds)->pluck('id')->toArray();
                $vulnAssetOwnerIds = Vulnerability::whereHas('assets', function ($query) use ($currentUser) {
                    $query->where('asset_owner', $currentUser->id);
                })->pluck('id')->toArray();
            } else {
                // Regular user logic...
                $teamIds = $currentUser->teams()->pluck('id')->toArray();
                $vulnerabilitiesFromTeamIds = TeamVulnerability::whereIn('team_id', $teamIds)->pluck('vulnerability_id')->toArray();
                $vulnerabilitiesFromCurrentUserIds = Vulnerability::where('created_by', auth()->id())->pluck('id')->toArray();

                // Fetch vulnerabilities for asset owner
                $vulnAssetOwnerIds = Vulnerability::whereHas('assets', function ($query) use ($currentUser) {
                    $query->where('asset_owner', $currentUser->id);
                })->pluck('id')->toArray();
            }

            $allVulnerabilitiesId = array_unique(array_merge(
                $vulnerabilitiesFromTeamIds,
                $vulnerabilitiesFromCurrentUserIds,
                $vulnAssetOwnerIds
            ), SORT_REGULAR);
        }
        $allVulnIds = null;
        if ($filterregion) {
            $vulnerabilityRegionIds = Vulnerability::select('id')->whereHas('assets.hostRegions', function ($query) use ($filterregion) {
                $query->where('host_regions.id', $filterregion);
            });
            if ($allVulnerabilitiesId) {
                $allVulnIds = array_unique(array_merge(
                    $allVulnerabilitiesId,
                    $vulnerabilityRegionIds
                ), SORT_REGULAR);
            } else {
                $allVulnIds = $vulnerabilityRegionIds;
            }
        } elseif ($filterassetGroup) {

            $vulnerabilityGroupIds = Vulnerability::select('id')->whereHas('assets.assetGroups', function ($query) use ($filterassetGroup) {
                $query->where('asset_groups.id', $filterassetGroup);
            });
            if ($allVulnerabilitiesId) {
                $allVulnIds = array_unique(array_merge(
                    $allVulnerabilitiesId,
                    $vulnerabilityGroupIds
                ), SORT_REGULAR);
            } else {
                $allVulnIds = $vulnerabilityGroupIds;
            }
        } else {
            if ($allVulnerabilitiesId) {
                $allVulnIds = $allVulnerabilitiesId;
            } else {
                $allVulnIds = null;
            }
        }

        if ($allVulnIds) {
            $conditions['whereIn'] = ['id' => $allVulnIds];
        }


        // Fetch total records count
        [$totalRecords, $totalRecordswithFilter] = getDatatableFilterTotalRecordsCount(
            Vulnerability::class,
            $dataTableDetails,
            $customFilterFields,
            $conditions
        );

        // Fetch records with filtering
        $mainTableColumns = getTableColumnsSelect(
            'vulnerabilities',
            [
                'id',
                'plugin_id',
                'name',
                'cve',
                'severity',
                'dns_name',
                'netbios_name',
                'status',
                'tenable_status',
                'port',
                'exploit',
                'created_at',
                'first_discovered',
                'description',
            ]
        );

        $vulnerabilities = getDatatableFilterRecords(
            Vulnerability::class,
            $dataTableDetails,
            $customFilterFields,
            $relationshipsWithColumns,
            $mainTableColumns,
            $conditions
        );

        // dd($vulnerabilities);

        // Prepare data for response
        $data_arr = [];

        foreach ($vulnerabilities as $vulnerability) {

            $regions = [];
            $assetGroups = [];
            $vulnerability->load(['assets.hostRegions', 'assets.assetGroups']);



            foreach ($vulnerability->assets as $asset) {
                $assetsWithRegions[] = [
                    'ip' => $asset->ip,
                    // Add any other asset-related data here if needed
                ];

                // Collect regions from this asset
                foreach ($asset->hostRegions as $region) {
                    $regions[] = $region->name; // Collecting unique region names
                }
                // Collect regions from this asset
                foreach ($asset->assetGroups as $assetGroup) {
                    $assetGroups[] = $assetGroup->name; // Collecting unique region names
                }
            }

             $data_arr[] = [
                'id' => $vulnerability->id,
                'plugin_id' => $vulnerability->plugin_id,
                'name' => $vulnerability->name,
                'cve' => $vulnerability->cve,
                // 'teams' => array_map(function ($element) {
                //     return $element['name'];
                // }, $vulnerability->teams->toArray()),
                'assets' => array_map(function ($element) {
                    return $element['ip'];
                }, $vulnerability->assets->toArray()),
                'regions' => array_unique($regions), // Add unique regions here
                'asset_group' => array_unique($assetGroups), // Add unique regions here
                'severity' => $vulnerability->severity,
                'dns_name' => $vulnerability->dns_name,
                'netbios_name' => $vulnerability->netbios_name,
                'status' => $vulnerability->status,
                'tenable_status' => $vulnerability->tenable_status,
                'port' => $vulnerability->port,
                'exploit' => $vulnerability->exploit,
                'first_discovered' => $vulnerability->first_discovered,
                'created_at' => $vulnerability->created_at->format('Y-m-d H:i'),
                'description' => $vulnerability->description,
                'Actions' => $vulnerability->id
            ];
        }

        // Return JSON response
        $response = getDatatableAjaxResponse(intval($dataTableDetails['draw']), $totalRecords, $totalRecordswithFilter, $data_arr);

        return response()->json($response, 200);
    }

    public function ajaxGetListInfo(Request $request)
    {
        // Initialize variables
        $dataTableDetails = [];
        $customFilterFields = [
            'normal' => ['plugin_id', 'name', 'cve', 'severity', 'status', 'exploit', 'tenable_status'],
            'relationships' => ['assets'],
            'other_global_filters' => ['created_at'],
        ];
        $relationshipsWithColumns = [
            'assets:ip',
            // 'teams:name'
        ];

        prepareDatatableRequestFields($request, $dataTableDetails, $customFilterFields);

        // Handle user permissions
        $currentUser = auth()->user();
        $conditions = [];

        // Get region filter from request
        $filterregion = $request->columns[13]['search']['value'] ?? '';
        $allVulnerabilitiesId = null;

        if (!$currentUser->hasPermission('vulnerability_management.all')) {
            if (isDepartmentManager()) {
                $departmentId = Department::where('manager_id', auth()->id())->first()->id;
                $departmentMembers = User::with('teams')->where('department_id', $departmentId)->orWhere('id', auth()->id())->get();
                $departmentMembersIds = $departmentMembers->pluck('id')->toArray();
                $departmentTeams = [];
                foreach ($departmentMembers as $departmentMember) {
                    $departmentTeams = array_merge($departmentTeams, $departmentMember->teams->pluck('id')->toArray());
                }
                $vulnerabilitiesFromTeamIds = TeamVulnerabilityInfo::whereIn('team_id', $departmentTeams)->pluck('vulnerability_id')->toArray();
                $vulnerabilitiesFromCurrentUserIds = VulnerabilityInfo::whereIn('created_by', $departmentMembersIds)->pluck('id')->toArray();
                $vulnAssetOwnerIds = VulnerabilityInfo::whereHas('assets', function ($query) use ($currentUser) {
                    $query->where('asset_owner', $currentUser->id);
                })->pluck('id')->toArray();
            } else {
                // Regular user logic...
                $teamIds = $currentUser->teams()->pluck('id')->toArray();
                $vulnerabilitiesFromTeamIds = TeamVulnerabilityInfo::whereIn('team_id', $teamIds)->pluck('vulnerability_id')->toArray();
                $vulnerabilitiesFromCurrentUserIds = VulnerabilityInfo::where('created_by', auth()->id())->pluck('id')->toArray();

                // Fetch vulnerabilities for asset owner
                $vulnAssetOwnerIds = VulnerabilityInfo::whereHas('assets', function ($query) use ($currentUser) {
                    $query->where('asset_owner', $currentUser->id);
                })->pluck('id')->toArray();
            }

            $allVulnerabilitiesId = array_unique(array_merge(
                $vulnerabilitiesFromTeamIds,
                $vulnerabilitiesFromCurrentUserIds,
                $vulnAssetOwnerIds
            ), SORT_REGULAR);
        }

        $allVulnIds = null;
        if ($filterregion) {
            $vulnerabilityRegionIds = VulnerabilityInfo::select('id')->whereHas('assets.hostRegions', function ($query) use ($filterregion) {
                $query->where('host_regions.id', $filterregion);
            });
            if ($allVulnerabilitiesId) {
                $allVulnIds = array_unique(array_merge(
                    $allVulnerabilitiesId,
                    $vulnerabilityRegionIds
                ), SORT_REGULAR);
            } else {
                $allVulnIds = $vulnerabilityRegionIds;
            }
        } else {
            if ($allVulnerabilitiesId) {
                $allVulnIds = $allVulnerabilitiesId;
            } else {
                $allVulnIds = null;
            }
        }

        if ($allVulnIds) {
            $conditions['whereIn'] = ['id' => $allVulnIds];
        }


        // Fetch total records count
        [$totalRecords, $totalRecordswithFilter] = getDatatableFilterTotalRecordsCount(
            VulnerabilityInfo::class,
            $dataTableDetails,
            $customFilterFields,
            $conditions
        );

        // Fetch records with filtering
        $mainTableColumns = getTableColumnsSelect(
            'vulnerability_infos',
            [
                'id',
                'plugin_id',
                'name',
                'cve',
                'severity',
                'status',
                'tenable_status',
                'port',
                'exploit',
                'created_at',
                'first_discovered',
                'dns_name',
                'netbios_name',
                'description',
            ]
        );

        $vulnerabilities = getDatatableFilterRecords(
            VulnerabilityInfo::class,
            $dataTableDetails,
            $customFilterFields,
            $relationshipsWithColumns,
            $mainTableColumns,
            $conditions
        );

        // dd($vulnerabilities);

        // Prepare data for response
        $data_arr = [];

        foreach ($vulnerabilities as $vulnerability) {
            $regions = [];
            $vulnerability->load(['assets.hostRegions']);

            foreach ($vulnerability->assets as $asset) {
                $assetsWithRegions[] = [
                    'ip' => $asset->ip,
                    // Add any other asset-related data here if needed
                ];

                // Collect regions from this asset
                foreach ($asset->hostRegions as $region) {
                    $regions[] = $region->name; // Collecting unique region names
                }
            }

            $data_arr[] = [
                'id' => $vulnerability->id,
                'plugin_id' => $vulnerability->plugin_id,
                'name' => $vulnerability->name,
                'cve' => $vulnerability->cve,
                // 'teams' => array_map(function ($element) {
                //     return $element['name'];
                // }, $vulnerability->teams->toArray()),
                'assets' => array_map(function ($element) {
                    return $element['ip'];
                }, $vulnerability->assets->toArray()),
                'regions' => array_unique($regions), // Add unique regions here
                'severity' => $vulnerability->severity,
                'dns_name' => $vulnerability->dns_name,
                'netbios_name' => $vulnerability->netbios_name,
                'status' => $vulnerability->status,
                'tenable_status' => $vulnerability->tenable_status,
                'port' => $vulnerability->port,
                'exploit' => $vulnerability->exploit,
                'first_discovered' => $vulnerability->first_discovered,
                'created_at' => $vulnerability->created_at->format('Y-m-d H:i'),
                'description' => $vulnerability->description,
                'Actions' => $vulnerability->id
            ];
        }

        // Return JSON response
        $response = getDatatableAjaxResponse(intval($dataTableDetails['draw']), $totalRecords, $totalRecordswithFilter, $data_arr);

        return response()->json($response, 200);
    }

    /**
     * Return an Export file for listing of the resource after some manipulation.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    // public function ajaxExport(Request $request)
    // {
    //     if ($request->type != 'pdf')
    //         return Excel::download(new VulnerabilitiesExport, 'Vulnerabilities.xlsx');
    //     else
    //         return 'Vulnerabilities.pdf';
    // }

    public function ajaxExport(Request $request)
    {

        $type = $request->type; // 'xlsx' or 'pdf'
        $tenable_status = $request->tenable_status;
        $severity = $request->severity;
        $region = $request->region;
        $assetgroup = $request->assetgroup;

        $message = $this->vulnsExportService->exportVulns($type, $tenable_status, $severity, $region, $assetgroup);

        return response()->json(['message' => $message]);
    }


    public function downloadExportedFile($filename)
    {
        $filePath = storage_path('app/exports/vulns/' . $filename);

        if (!file_exists($filePath)) {
            abort(404, 'File not found.');
        }

        return response()->download($filePath, $filename);
    }


    /**
     * function to send actions of module to notifications view
     *
     */
    public function notificationsSettings()
    {

        // defining the breadcrumbs that will be shown in page
        $breadcrumbs = [['link' => route('admin.dashboard'), 'name' => __('locale.Dashboard')], ['link' => route('admin.vulnerability_management.index'), 'name' => __('locale.VulnerabilityManagement')], ['name' => __('locale.NotificationsSettings')]];
        $users = User::select('id', 'name')->where('enabled', true)->get();  // getting all users to list them in select input of users
        $moduleActionsIds = [1, 2, 3, 123];   // defining ids of actions modules
        $moduleActionsIdsAutoNotify = [];  // defining ids of actions modules

        // defining variables associated with each action "for the user to choose variables he wants to add to the message of notification" "each action id will be the array key of action's variables list"
        $actionsVariables = [
            1 => ['name', 'cve', 'description', 'severity', 'recommendation', 'plan', 'status', 'teams', 'assets', 'protocol', 'synopsis'],
            2 => ['name', 'cve', 'description', 'severity', 'recommendation', 'plan', 'status', 'teams', 'assets', 'protocol', 'synopsis'],
            3 => ['name', 'cve', 'description', 'severity', 'recommendation', 'plan', 'status', 'teams', 'assets', 'protocol', 'synopsis'],
            123 => []
        ];
        // defining roles associated with each action "for the user to choose roles he wants to sent the notification to" "each action id will be the array key of action's roles list"
        $actionsRoles = [
            1 => ['creator' => __('vulnerability.VulnerabilityCreator'), 'Team-teams' => __('vulnerability.TeamsOfVulnerability'), 'Asset-Owner' => __('asset.AssetOwner')],
            2 => ['creator' => __('vulnerability.VulnerabilityCreator'), 'Team-teams' => __('vulnerability.TeamsOfVulnerability'), 'Asset-Owner' => __('asset.AssetOwner')],
            3 => ['creator' => __('vulnerability.VulnerabilityCreator'), 'Team-teams' => __('vulnerability.TeamsOfVulnerability'), 'Asset-Owner' => __('asset.AssetOwner')],
            123 => []
        ];
        // getting actions with their system notifications settings, sms settings and mail settings to list them in tables
        $actionsWithSettings = Action::whereIn('actions.id', $moduleActionsIds)
            ->leftJoin('system_notifications_settings', 'actions.id', '=', 'system_notifications_settings.action_id')
            ->leftJoin('mail_settings', 'actions.id', '=', 'mail_settings.action_id')
            ->leftJoin('sms_settings', 'actions.id', '=', 'sms_settings.action_id')
            ->get([
                'actions.id as action_id',
                'actions.name as action_name',
                'system_notifications_settings.id as system_notification_setting_id',
                'system_notifications_settings.status as system_notification_setting_status',
                'mail_settings.id as mail_setting_id',
                'mail_settings.status as mail_setting_status',
                'sms_settings.id as sms_setting_id',
                'sms_settings.status as sms_setting_status',
            ]);
        $actionsWithSettingsAuto = [];
        return view('admin.notifications-settings.index', compact('breadcrumbs', 'users', 'actionsWithSettings', 'actionsVariables', 'actionsRoles', 'moduleActionsIdsAutoNotify', 'actionsWithSettingsAuto'));
    }

    // This function is used to open the import form and send the required data for it
    public function openImportForm()
    {
        // Defining breadcrumbs for the page
        $breadcrumbs = [
            ['link' => route('admin.dashboard'), 'name' => __('locale.Dashboard')],
            ['link' => route('admin.vulnerability_management.index'), 'name' => __('locale.Vulnerabilities')],
            ['name' => __('locale.Import')]
        ];

        // Defining database columns with rules and examples
        $databaseColumns = [
            // Column: 'plugin_id'
            ['name' => 'plugin_id', 'rules' => ['can be empty'], 'example' => 1234],

            // Column: 'plugin_name'
            ['name' => 'plugin_name', 'rules' => ['required'], 'example' => 'Vulnerability 1'],

            // Column: 'ip_address'
            ['name' => 'ip_address', 'rules' => ['must be ip', 'should exist in assets table', 'if it doesnt exist an asset will be created with the same ip'], 'example' => '192.168.1.1'],

            // Column: 'cve'
            ['name' => 'cve', 'rules' => ['can be empty'], 'example' => 'cve'],

            // Column: 'teams'
            ['name' => 'teams', 'rules' => [
                'can be empty',
                'should be written as comma-separated text',
                'must exist in teams of the system. Teams not in the system will be removed'
            ], 'example' => 'Team1, Team2'],

            // Column: 'severity'
            ['name' => 'severity', 'rules' => [
                'required',
                'must have value Critical or High or Medium or Low or Informational',
            ], 'example' => 'critical'],

            // Column: 'dns_name'
            ['name' => 'dns_name', 'rules' => ['can be empty'], 'example' => 'dns name'],

            // Column: 'netbios_name'
            ['name' => 'netbios_name', 'rules' => ['can be empty'], 'example' => 'netbios name'],

            // Column: 'protocol'
            ['name' => 'protocol', 'rules' => ['can be empty'], 'example' => 'ucp'],

            // Column: 'port'
            ['name' => 'port', 'rules' => ['can be empty', 'should be number'], 'example' => 5],

            // Column: 'exploit'
            ['name' => 'exploit', 'rules' => ['can be empty', 'must have value yes or no'], 'example' => 'no'],


            // Column: 'synopsis'
            ['name' => 'synopsis', 'rules' => ['can be empty'], 'example' => 'Synosis'],

            // Column: 'first_discovered'
            ['name' => 'first_discovered', 'rules' => [
                'can be empty',
                'must be date time in this form: mon dd, yyyy hh:mm:ss UTC'
            ], 'example' => 'Oct 17, 2023 20:38:34 UTC'],

            // Column: 'last_observed'
            ['name' => 'last_observed', 'rules' => [
                'can be empty',
                'must be date time in this form: mon dd, yyyy hh:mm:ss UTC'
            ], 'example' => 'Oct 17, 2023 20:38:34 UTC'],

            // Column: 'plugin_publication_date'
            [
                'name' => 'plugin_publication_date',
                'rules' => [
                    'can be empty',
                    'must be date time in this form: mon dd, yyyy hh:mm:ss UTC'
                ],
                'example' => 'Oct 17, 2023 20:38:34 UTC'
            ],

            // Column: 'plugin_modification_date'
            ['name' => 'plugin_modification_date', 'rules' => [
                'can be empty',
                'must be date time in this form: mon dd, yyyy hh:mm:ss UTC'
            ], 'example' => 'Oct 17, 2023 20:38:34 UTC'],

            // Column: 'description'
            ['name' => 'description', 'rules' => ['can be empty'], 'example' => 'Some description'],

            // Column: 'solution'
            ['name' => 'solution', 'rules' => ['can be empty'], 'example' => 'Some solution'],


            // Column: 'plugin_output'
            ['name' => 'plugin_output', 'rules' => ['can be empty'], 'example' => 'Some plugin output'],

            // Column: 'status'
            ['name' => 'status', 'rules' => [
                'can be empty',
                'must have value Open or In Progress or Closed or Overdue',
            ], 'example' => 'Open'],

        ];

        // Define the path for the import data function
        $importDataFunctionPath = route('admin.vulnerability_management.ajax.importData');

        // Return the view with necessary data
        return view('admin.import.index', compact('breadcrumbs', 'databaseColumns', 'importDataFunctionPath'));
    }


    // This function is used to validate the data coming from mapping column and then
    // sending them to "VulnerabilityImport" class to import its data
    public function importData(Request $request)
    {
        // Validate the incoming request for the 'import_file' field
        $validator = Validator::make($request->all(), [
            'import_file' => ['required', 'file', 'max:5000'],
        ]);

        // Check for validation errors
        if ($validator->fails()) {
            $errors = $validator->errors()->toArray();

            // Prepare response with validation errors
            $response = [
                'status' => false,
                'errors' => $errors,
                'message' => __('locale.ThereWasAProblemImportingTheItem', ['item' => __('locale.Vulnerabilities')])
                    . "<br>" . __('locale.Validation error'),
            ];
            return response()->json($response, 422);
        } else {
            // Start a database transaction
            DB::beginTransaction();
            try {
                // Mapping columns from the request to database columns
                $columnsMapping = array();
                $columns = [
                    'plugin_id',
                    'plugin_name',
                    'ip_address',
                    'cve',
                    'teams',
                    'severity',
                    'dns_name',
                    'netbios_name',
                    'protocol',
                    'port',
                    'exploit',
                    'synopsis',
                    'first_discovered',
                    'last_observed',
                    'plugin_publication_date',
                    'plugin_modification_date',
                    'description',
                    'solution',
                    'plugin_output',
                    'status'
                ];

                foreach ($columns as $column) {
                    if ($request->has($column)) {
                        $inputValue = $request->input($column);
                        $cleanedColumn = str_replace(
                            ["/", "(", ")", "'", "#", "*", "+", "%", "&", "$", "=", "<", ">", "?", "", ":", ";", '"', ".", "^", ",", "@", "-", " "],
                            ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '_at_', '_', '_'],
                            strtolower($inputValue)
                        );

                        $cleanedColumn = str_replace(
                            ["__"],
                            ['_'],
                            $cleanedColumn
                        );
                        $cleanedColumn = preg_replace('/(\w+)_\b/', '$1', $cleanedColumn);
                        $snakeCaseColumn = Str::snake($cleanedColumn);
                        $columnsMapping[$column] = $snakeCaseColumn;
                    }
                }

                // Extract values and filter out null values
                $values = array_values(array_filter($columnsMapping, function ($value) {
                    if ($value != null && $value != '') {
                        return $value;
                    }
                }));

                // Check for duplicate values
                if (count($values) !== count(array_unique($values))) {
                    $response = [
                        'status' => false,
                        'message' => __('locale.YouCantUseTheSameFileColumnForMoreThanOneDatabaseColumn'),
                    ];
                    return response()->json($response, 422);
                }

                // Import data using the specified columns mapping
                (new VulnerabilitiesImport($columnsMapping))->import(request()->file('import_file'));

                // Commit the transaction
                DB::commit();
                $message = __("locale.New Data Imported At Vulnerability") . " \" " . __("locale.CreatedBy") . " \"" . auth()->user()->name . "\".";
                write_log(1, auth()->id(), $message);
                // Prepare success response
                $response = [
                    'status' => true,
                    'reload' => true,
                    'message' => __('locale.ItemWasImportedSuccessfully', ['item' => __('locale.Vulnerabilities')]),
                ];
                return response()->json($response, 200);
            } catch (\Maatwebsite\Excel\Validators\ValidationException $e) {
                // Rollback the transaction in case of an exception
                DB::rollBack();

                // Handle validation exceptions and prepare error response
                $failures = $e->failures();
                $errors = [];
                foreach ($failures as $failure) {
                    if (!array_key_exists($failure->row(), $errors)) {
                        $errors[$failure->row()] = [];
                    }
                    $errors[$failure->row()][] = [
                        'attribute' => $failure->attribute(),
                        'value' =>  $failure->values()[$failure->attribute()] ?? '',
                        'error' => $failure->errors()[0]
                    ];
                }

                $response = [
                    'status' => false,
                    'errors' => $errors,
                    'message' => __('locale.ThereWasAProblemImportingTheItem', ['item' => __('locale.Vulnerabilities')]),
                ];
                return response()->json($response, 502);
            }
        }
    }


    // This function is used to open the import form and send the required data for it
    public function openCloseVulnerabilitiesForm()
    {
        // Defining breadcrumbs for the page
        $breadcrumbs = [
            ['link' => route('admin.dashboard'), 'name' => __('locale.Dashboard')],
            ['link' => route('admin.vulnerability_management.index'), 'name' => __('locale.Vulnerabilities')],
            ['name' => __('locale.CloseVulnerabilities')]
        ];

        // Defining database columns with rules and examples
        $databaseColumns = [
            // Column: 'plugin_id'
            ['name' => 'plugin_id', 'rules' => ['required'], 'example' => 1234],

            // Column: 'ip_address'
            ['name' => 'ip_address', 'rules' => ['required', 'must be ip'], 'example' => '192.168.1.1'],

            // Column: 'port'
            ['name' => 'port', 'rules' => ['required', 'should be number'], 'example' => 5],

            // Column: 'first_discovered'
            ['name' => 'first_discovered', 'rules' => [
                'required',
                'must be date time in this form: mon dd, yyyy hh:mm:ss UTC'
            ], 'example' => 'Oct 17, 2023 20:38:34 UTC'],
        ];

        // Define the path for the import data function
        $importDataFunctionPath = route('admin.vulnerability_management.ajax.importClosedVulnerabilities');

        // Return the view with necessary data
        return view('admin.import.index', compact('breadcrumbs', 'databaseColumns', 'importDataFunctionPath'));
    }


    // This function is used to validate the data coming from mapping column and then
    // sending them to "ClosedVulnerabilityImport" class to import its data
    public function importClosedVulnerabilities(Request $request)
    {
        // Validate the incoming request for the 'import_file' field
        $validator = Validator::make($request->all(), [
            'import_file' => ['required', 'file', 'max:5000'],
        ]);

        // Check for validation errors
        if ($validator->fails()) {
            $errors = $validator->errors()->toArray();

            // Prepare response with validation errors
            $response = [
                'status' => false,
                'errors' => $errors,
                'message' => __('locale.ThereWasAProblemImportingTheItem', ['item' => __('locale.Vulnerabilities')])
                    . "<br>" . __('locale.Validation error'),
            ];
            return response()->json($response, 422);
        } else {
            // Start a database transaction
            DB::beginTransaction();
            try {
                // Mapping columns from the request to database columns
                $columnsMapping = array();
                $columns = [
                    'plugin_id',
                    'ip_address',
                    'port',
                    'first_discovered',
                ];

                foreach ($columns as $column) {
                    if ($request->has($column)) {
                        $inputValue = $request->input($column);
                        $cleanedColumn = str_replace(
                            ["/", "(", ")", "'", "#", "*", "+", "%", "&", "$", "=", "<", ">", "?", "", ":", ";", '"', ".", "^", ",", "@", "-", " "],
                            ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '_at_', '_', '_'],
                            strtolower($inputValue)
                        );

                        $cleanedColumn = str_replace(
                            ["__"],
                            ['_'],
                            $cleanedColumn
                        );
                        $cleanedColumn = preg_replace('/(\w+)_\b/', '$1', $cleanedColumn);
                        $snakeCaseColumn = Str::snake($cleanedColumn);
                        $columnsMapping[$column] = $snakeCaseColumn;
                    }
                }

                // Extract values and filter out null values
                $values = array_values(array_filter($columnsMapping, function ($value) {
                    if ($value != null && $value != '') {
                        return $value;
                    }
                }));

                // Check for duplicate values
                if (count($values) !== count(array_unique($values))) {
                    $response = [
                        'status' => false,
                        'message' => __('locale.YouCantUseTheSameFileColumnForMoreThanOneDatabaseColumn'),
                    ];
                    return response()->json($response, 422);
                }

                // Import data using the specified columns mapping
                (new ClosedVulnerabilitiesImport($columnsMapping))->import(request()->file('import_file'));

                // Commit the transaction
                DB::commit();
                $message = __("locale.New Data Imported And Closed At Vulnerability") . " \" " . __("locale.CreatedBy") . " \"" . auth()->user()->name . "\".";
                write_log(1, auth()->id(), $message);
                // Prepare success response
                $response = [
                    'status' => true,
                    'reload' => true,
                    'message' => __('locale.ItemWasImportedSuccessfully', ['item' => __('locale.Vulnerabilities')]),
                ];
                return response()->json($response, 200);
            } catch (\Maatwebsite\Excel\Validators\ValidationException $e) {
                // Rollback the transaction in case of an exception
                DB::rollBack();

                // Handle validation exceptions and prepare error response
                $failures = $e->failures();
                $errors = [];
                foreach ($failures as $failure) {
                    if (!array_key_exists($failure->row(), $errors)) {
                        $errors[$failure->row()] = [];
                    }
                    $errors[$failure->row()][] = [
                        'attribute' => $failure->attribute(),
                        'value' =>  $failure->values()[$failure->attribute()] ?? '',
                        'error' => $failure->errors()[0]
                    ];
                }

                $response = [
                    'status' => false,
                    'errors' => $errors,
                    'message' => __('locale.ThereWasAProblemImportingTheItem', ['item' => __('locale.Vulnerabilities')]),
                ];
                return response()->json($response, 502);
            }
        }
    }


    public function storeControlNotificationVuln(Request $request)
    {
        // Validate the request
        $validatedData = $request->validate([
            'status' => 'nullable|string',
            'severity' => 'nullable|string',
            'vuln_asset_region' => 'nullable|string',
            'exploit' => 'nullable|string',
            'first_discovered' => 'nullable|date',
            'last_discovered' => 'nullable|date|after_or_equal:first_discovered|required_with:first_discovered',
        ]);

        // Update or create the record, excluding 'one_record' from the validated data
        $record = ControlNotificationVulnToAssetOwner::updateOrCreate(
            ['id' => 1], // Assuming there is only one record with ID 1
            $validatedData // This does not include 'one_record'
        );

        // Retrieve the updated or created record
        $data = ControlNotificationVulnToAssetOwner::find($record->id);

        // Query to get vulnerabilities based on the conditions
        $vulns = Vulnerability::where(function ($query) use ($data) {
            // Check for status if it's not null


            if ($data->status) {
                $query->where('tenable_status', $data->status);
            }

            if ($data->vuln_asset_region) {
                $filterregion = $data->vuln_asset_region;
                $query->whereHas('assets.hostRegions', function ($query) use ($filterregion) {
                    $query->where('host_regions.id', $filterregion);
                });
            }

            // Check for severity if it's not null
            if ($data->severity) {
                $query->where('severity', $data->severity);
            }

            // Check for exploit if it's not null
            if ($data->exploit) {
                $query->where('exploit', $data->exploit);
            }

            // Check for date range only if first_discovered and last_discovered are not null
            if ($data->first_discovered && $data->last_discovered) {
                // Normalize the first_discovered date
                $startDate = Carbon::parse($data->first_discovered)->startOfDay();
                // Normalize the last_discovered date
                $endDate = Carbon::parse($data->last_discovered)->endOfDay();

                $query->whereBetween('first_discovered', [$startDate, $endDate]);
            }
        })->with('assets')->get(); // Fetch all matching vulnerabilities with assets

        // Group vulnerabilities by asset owner
        $groupedVulns = $vulns->flatMap(function ($vuln) {
            return $vuln->assets->map(function ($asset) use ($vuln) {
                return [
                    'asset_owner' => $asset->asset_owner,
                    'name' => $vuln->name, // Changed key from 'vuln_name' to 'name'
                    'status' => $vuln->tenable_status,
                    'severity' => $vuln->severity,
                ];
            });
        })->groupBy('asset_owner');

        // Dispatch a job for each unique asset owner
        foreach ($groupedVulns as $assetOwner => $vulnData) {
            // Retrieve the email from the users table using the asset owner's ID
            $user = User::find($assetOwner);
            // dd($groupedVulns );

            if ($user && $user->email) {
                // Include the email address in the data to be passed to the job
                $emailData = [
                    'email' => $user->email, // Get the user's email
                    'vulnerabilities' => $vulnData->toArray() // Convert to array for the job
                ];
                SendVulnerabilityEmail::dispatch($emailData);
            } else {
                // Log an error or handle the case where the user is not found
                Log::warning("User not found for asset owner ID: $assetOwner");
            }
        }

        // Return the response
        return response()->json([
            'message' => 'Emails are being sent successfully.',
            'grouped_vulnerabilities' => $groupedVulns,
        ]);
    }


    // get the first record of control in notification
    public function getFirstRecord()
    {
        $record = ControlNotificationVulnToAssetOwner::first();

        if ($record) {
            return response()->json(['data' => $record]);
        }

        return response()->json(['data' => null]);
    }
    public function tenableHistory()
    {

        $regions = HostRegion::select('id', 'name')->get();
        $breadcrumbs = [['link' => route('admin.dashboard'), 'name' => __('locale.Dashboard')], ['name' => __('locale.TenableHistory')]];


        return view('admin.content.vulnerability_management.tenable-history', compact('breadcrumbs', 'regions'));
    }

    public function regionHistory(Request $request)
    {
        $regions = array_map('intval', (array) $request->input('region_id')); // Ensure IDs are integers
        $regionsName = HostRegion::where('id', $request->input('region_id'))->first()->name; // Ensure IDs are integers

        // Fetch matching asset IDs
        $assetIds = DB::table('asset_host_region')
            ->whereIn('host_region_id', $regions)
            ->pluck('asset_id')
            ->toArray();

        // Fetch vulnerability history for the last 4 months
        $vulnHistory = DB::table('tenable_histories')
            ->whereIn('asset_id', $assetIds)
            ->where('status', "Closed")
            ->whereBetween('created_at', [now()->subMonths(4)->startOfMonth(), now()->endOfMonth()])
            ->selectRaw('
                YEAR(created_at) AS year,
                MONTH(created_at) AS month,
                COUNT(CASE WHEN severity = "Critical" THEN 1 END) AS critical_count,
                COUNT(CASE WHEN severity = "High" THEN 1 END) AS high_count,
                COUNT(CASE WHEN severity = "Medium" THEN 1 END) AS medium_count,
                COUNT(CASE WHEN severity = "Low" THEN 1 END) AS low_count
            ')
            ->groupBy(DB::raw('YEAR(created_at), MONTH(created_at)'))
            ->orderBy('year')
            ->orderBy('month')
            ->get();

        // Initialize an array for the last 4 months with zero counts
        $lastFourMonths = [];
        for ($i = 1; $i <= 4; $i++) {
            $month = now()->subMonths($i);
            $lastFourMonths[] = [
                'year' => $month->year,
                'month' => $month->month,
                'critical_count' => 0,
                'high_count' => 0,
                'medium_count' => 0,
                'low_count' => 0,
            ];
        }

        // Merge fetched data with the initialized last 4 months array, overriding with actual data
        foreach ($vulnHistory as $record) {
            foreach ($lastFourMonths as &$monthData) {
                if ($monthData['year'] == $record->year && $monthData['month'] == $record->month) {
                    $monthData['critical_count'] = $record->critical_count;
                    $monthData['high_count'] = $record->high_count;
                    $monthData['medium_count'] = $record->medium_count;
                    $monthData['low_count'] = $record->low_count;
                    break;
                }
            }
        }

        // Reverse the order of the months array to start with the most recent month
        $lastFourMonths = array_reverse($lastFourMonths);

        // Calculate totals for the most recent month
        $mostRecentMonth = end($lastFourMonths); // Get the last month in the array
        $totalForLastMonth = [
            'critical' => $mostRecentMonth['critical_count'],
            'high' => $mostRecentMonth['high_count'],
            'medium' => $mostRecentMonth['medium_count'],
            'low' => $mostRecentMonth['low_count'],
        ];

        // Transform data for Highcharts
        $vulnHistoryData = [
            'regionsName' => $regionsName,
            'months' => [],
            'critical' => [],
            'high' => [],
            'medium' => [],
            'low' => [],
            'totalsLastMonth' => $totalForLastMonth, // Add totals for the pie chart
        ];

        foreach ($lastFourMonths as $record) {
            $monthName = \Carbon\Carbon::create($record['year'], $record['month'])->format('F Y');
            $vulnHistoryData['months'][] = $monthName;
            $vulnHistoryData['critical'][] = $record['critical_count'];
            $vulnHistoryData['high'][] = $record['high_count'];
            $vulnHistoryData['medium'][] = $record['medium_count'];
            $vulnHistoryData['low'][] = $record['low_count'];
        }
        return response()->json($vulnHistoryData);
    }

    public function assetHistory(Request $request)
    {
        $assetId = array_map('intval', (array) $request->input('asset_id')); // Ensure IDs are integers

        // Fetch the asset name
        $asset = Asset::whereIn('id', $assetId)->first(); // Adjusted for latest asset
        $assetName = $asset ? $asset->name : 'Unknown Asset';

        // Define the date ranges
        $fourMonthsAgoStart = now()->subMonths(4)->startOfMonth();
        $lastMonthStart = now()->subMonth()->startOfMonth();
        $lastMonthEnd = now()->subMonth()->endOfMonth();

        // Combined query
        $historyData = DB::table('tenable_histories')
            ->whereIn('asset_id', $assetId)
            ->whereBetween('created_at', [$fourMonthsAgoStart, $lastMonthEnd])
            ->selectRaw('
                YEAR(created_at) AS year,
                MONTH(created_at) AS month,
                COUNT(CASE WHEN status = "Open" THEN 1 END) AS open_count,
                COUNT(CASE WHEN status = "Closed" THEN 1 END) AS closed_count,
                COUNT(CASE WHEN status = "Closed" AND severity = "Critical" AND created_at BETWEEN ? AND ? THEN 1 END) AS critical_count,
                COUNT(CASE WHEN status = "Closed" AND severity = "High" AND created_at BETWEEN ? AND ? THEN 1 END) AS high_count,
                COUNT(CASE WHEN status = "Closed" AND severity = "Medium" AND created_at BETWEEN ? AND ? THEN 1 END) AS medium_count,
                COUNT(CASE WHEN status = "Closed" AND severity = "Low" AND created_at BETWEEN ? AND ? THEN 1 END) AS low_count
            ', [
                $lastMonthStart,
                $lastMonthEnd,
                $lastMonthStart,
                $lastMonthEnd,
                $lastMonthStart,
                $lastMonthEnd,
                $lastMonthStart,
                $lastMonthEnd
            ])
            ->groupBy(DB::raw('YEAR(created_at), MONTH(created_at)'))
            ->orderBy('year')
            ->orderBy('month')
            ->get();

        // Generate the range of months for the previous 4 months (excluding the current month)
        $monthsRange = [];
        for ($i = 1; $i <= 4; $i++) {
            $monthsRange[] = now()->subMonths($i)->format('Y-m');
        }

        // Initialize the data structure for the response
        $vulnAssetHistoryData = [
            'assetName' => $assetName, // Include asset name here
            'months' => [],
            'open' => [],
            'closed' => [],
            'severity' => [
                'critical' => 0,
                'high' => 0,
                'medium' => 0,
                'low' => 0,
            ],
        ];

        // Map the fetched history by year-month for easier lookup
        $vulnHistoryMap = $historyData->keyBy(function ($item) {
            return $item->year . '-' . str_pad($item->month, 2, '0', STR_PAD_LEFT);
        });

        // Process the months range and fill missing months with 0 values
        foreach ($monthsRange as $month) {
            $monthName = \Carbon\Carbon::createFromFormat('Y-m', $month)->format('F Y');

            if (isset($vulnHistoryMap[$month])) {
                $vulnAssetHistoryData['open'][] = $vulnHistoryMap[$month]->open_count;
                $vulnAssetHistoryData['closed'][] = $vulnHistoryMap[$month]->closed_count;
            } else {
                $vulnAssetHistoryData['open'][] = 0;
                $vulnAssetHistoryData['closed'][] = 0;
            }

            $vulnAssetHistoryData['months'][] = $monthName;
        }

        // Set the totals for the last month (the last entry in the months range)
        $lastMonth = reset($monthsRange); // Get the first month from the months range

        // Populate severity data from the last month (assumed to be the last row in the query)
        if ($lastMonthData = $vulnHistoryMap[$lastMonth] ?? null) {
            $vulnAssetHistoryData['severity'] = [
                'critical' => $lastMonthData->critical_count ?? 0,
                'high' => $lastMonthData->high_count ?? 0,
                'medium' => $lastMonthData->medium_count ?? 0,
                'low' => $lastMonthData->low_count ?? 0,
            ];
        }

        return response()->json($vulnAssetHistoryData);
    }

    public function vulnStatistics()
    {
        $breadcrumbs = [
            ['link' => route('admin.dashboard'), 'name' => __('locale.Dashboard')],

            ['link' => route('admin.vulnerability_management.index'), 'name' => __('locale.VulnerabilityManagement')],
            ['name' => __('statistics vuln')],
        ];

        $vulnOpenAndClosedWithSeverity = $this->StatisticsSeverityStatus();
        $vulnWithTopGetPriorityVuln = $this->GetPriorityVuln();
        $GetVulnCriticalOnDepartement = $this->GetVulnCriticalOnDepartement();
        $GetVulnCloseRateInwave = $this->GetVulnCloseRateInwave();

        // Capture the returned data from GetVulnCloseRateInwave method
        $chartData = $GetVulnCloseRateInwave['chartData'];
        $months = $GetVulnCloseRateInwave['months'];

        // Prepare data for donut chart
        $criticalDeptData = array_map(function ($count, $dept) {
            return ['name' => $dept, 'y' => $count];
        }, $GetVulnCriticalOnDepartement, array_keys($GetVulnCriticalOnDepartement));


        // Pass both chartData and months to the view
        return view('admin.content.vulnerability_management.vulnstatistics', compact(
            'vulnOpenAndClosedWithSeverity',
            'vulnWithTopGetPriorityVuln',
            'GetVulnCriticalOnDepartement',
            'criticalDeptData',
            'chartData',   // Add chartData to the view
            'months',      // Add months to the view
            'breadcrumbs'
        ));
    }



    public function StatisticsSeverityStatus()
    {
        // Group and count vulnerabilities by severity and status
        $vulnData = Vulnerability::select('status', 'severity', DB::raw('COUNT(*) as count'))
            ->groupBy('status', 'severity')
            ->get();

        // Prepare data structured by severity and status
        $result = [
            'Critical' => ['Open' => 0, 'Closed' => 0],
            'High' => ['Open' => 0, 'Closed' => 0],
            'Medium' => ['Open' => 0, 'Closed' => 0],
            'Low' => ['Open' => 0, 'Closed' => 0],
        ];

        // Populate the data
        foreach ($vulnData as $item) {
            $status = $item->status;
            $severity = $item->severity;
            $count = $item->count;

            if (isset($result[$severity])) {
                $result[$severity][$status] = $count;
            }
        }

        return $result;
    }


    public function GetPriorityVuln()
    {
        // Fetch top 5 vulnerabilities with status 'Open' and severity 'Critical', sorted by latest
        return Vulnerability::where('status', 'Open')
            ->where('severity', 'Critical')
            ->orderBy('created_at', 'desc') // Assumes there's a 'created_at' timestamp column
            ->limit(5)
            ->get();
    }

    public function GetVulnCriticalOnDepartement()
    {
        // Fetch vulnerabilities with 'Open' status and 'Critical' severity
        $vulnerabilities = Vulnerability::where('status', 'Open')
            ->where('severity', 'Critical')
            ->with('assets') // Assuming 'assets' is a valid relationship in Vulnerability model
            ->get();
        // Prepare department count array
        $departmentVulnCount = [];

        foreach ($vulnerabilities as $vuln) {
            foreach ($vuln->assets as $asset) {
                $user = User::where('id', $asset->asset_owner)->first();

                if ($user && $user->department_id) {
                    // If the user has a department, get the department name
                    $department = Department::find($user->department_id);
                    if ($department) {
                        $deptName = $department->name;

                        // Increment the count for this department
                        if (!isset($departmentVulnCount[$deptName])) {
                            $departmentVulnCount[$deptName] = 0;
                        }

                        $departmentVulnCount[$deptName]++;
                    }
                } else {
                    // If no department is assigned, increment the "No Department" count
                    if (!isset($departmentVulnCount['No Department'])) {
                        $departmentVulnCount['No Department'] = 0;
                    }

                    $departmentVulnCount['No Department']++;
                }
            }
        }
        return $departmentVulnCount;
    }




    public function GetVulnCloseRateInwave()
    {
        // Define the date range (last three months)
        $endDate = now();
        $startDate = now()->subMonths(3);

        // Fetch vulnerabilities with 'Closed' status filtered by `last_observed`
        $vulnData = Vulnerability::where('status', 'Closed')
            ->whereBetween('last_observed', [$startDate, $endDate])
            ->where('severity', 'Critical')  // Filter only Critical severity
            ->selectRaw('DATE_FORMAT(last_observed, "%Y-%m") as month, COUNT(*) as count')
            ->groupBy('month')
            ->orderBy('month')
            ->get();

        // Prepare data for Highcharts
        $chartData = [];
        $months = [];

        // Fill data for each month
        foreach ($vulnData as $item) {
            $month = $item->month;
            $count = $item->count;

            // Add count to the corresponding month
            $chartData[$month] = $count;

            if (!in_array($month, $months)) {
                $months[] = $month;
            }
        }

        // Ensure that we have exactly three months on the X-axis (if data exists for all months)
        $allMonths = [];
        foreach (range(0, 2) as $i) {
            $allMonths[] = now()->subMonths(2 - $i)->format('Y-m');
        }

        // Convert the month-year format to month name (e.g., '2024-11' -> 'November')
        $monthNames = array_map(function ($month) {
            return \Carbon\Carbon::parse($month)->format('F');  // 'F' gives the full month name
        }, $allMonths);

        // Fill missing months with 0 counts (if any)
        foreach ($allMonths as $month) {
            if (!isset($chartData[$month])) {
                $chartData[$month] = 0;
            }
        }

        // Format data for Highcharts
        $formattedData = [
            [
                'name' => 'Critical Vulnerabilities',
                'data' => array_values($chartData),
            ]
        ];

        return [
            'chartData' => json_encode($formattedData),
            'months' => json_encode(array_reverse($monthNames)),  // Ensure months are reversed for the correct display
        ];
    }
}
